\section{Optimizations}
\label{section:optimizations}
\textbf{WIP}

\subsection{Batched FRI}

Instead of checking each commitment individualy, it is possible to aggregate them 
for FRI.
For polynomials $f_0, \dots, f_k$:
\begin{enumerate}
    \item Get $\theta$ from transcript
    \item $f = f_0 \cdot \theta^{k - 1} + \dots + f_k$
    \item Run FRI over $f$, using oracles to $f_0, \dots, f_k$
\end{enumerate}

Thus, we can run only one FRI instance for all commited polynomials.

See \cite{cryptoeprint:2019:1400} for details.

\subsection{Hash By Column}

Instead of committing each of the polynomials, it is possible to use the same Merkle 
tree for several polynomials.
This leads to the decrease of the number of Merkle tree paths which are required
to be provided by the prover.

See \cite{cryptoeprint:2019:1076}, \cite{cryptoeprint:2019:1400} for details.

\subsection{Hash By Subset}

Each $i + 1$ FRI round supposes the prover to send all elements from a coset $H \in D^{(i)}$.
Each Merkle leaf is able to contain the whole coset instead of separate values.

See \cite{cryptoeprint:2019:1076} for details.
Similar approach is described in \cite{cryptoeprint:2019:1400}.
However, the authors of \cite{cryptoeprint:2019:1400} use more values per leaf, that leads to better performance. 
